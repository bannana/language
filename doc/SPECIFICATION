                             Detailed Specification for
                                  Various Componets

                           Paul Longtine (paul@nanner.co)

OVERVIEW
    This language will look and feel like any other normal, ordinary language.
The goal is not to innovate, but to see if _I_ can. This is a personal refuge
before my inevitable contributions to large group projects where individuals
are deemed inferior.

 SYNTAX
    #TO BE DETERMINED#

 TYPES
    Providing basic types, such as:
 * integer
 * float
 * character
 * boolean
    Will be elaborated on as thoughts progress.

RUNTIME

    Code in the runtime is organized on a per-function basis.

'Function' in this case means a callable block of code which may or may not retu
rn a value.

 +---------+
 |Function | -> Function is 'defined', when called with reference a new scope is
 +---------+    formed, along with arguements being supplied. Can support object
                oriented behaviour with preserving scopes, and providing access
                methods to member functions.

    Variables (and functions) exist under various scopes. The scopes are as 
follows:
  * Temporary Scope
  * Local Scope
  * Global Scope

    Temporary scope variables are variables declared outside the Root method.
The Root method is the code that is ran any time a 'module' of code is evaluated
and/or imported. A 'module' is any file containing code. Local Scope variables
are variables in which are visible to the module, and only the module. Global
scope variables are visible anywhere within the runtime.

    A stack is used to keep a local group of values to manipulate. Values are
pushed on to the stack and are operated upon, and the values in the stack can
but assigned or re-assigned to variables.

 Bytecode Instructions

Keywords:
 TOS - 'Top Of Stack' The top element
-------------------------------------------------------------------------------
Stack manipulation
-------------------------------------------------------------------------------
 POP <n>   - pops the stack n times.
 ROT       - rotates top of stack
 ROT_THREE - rotates top three elements of stack
 DUP       - duplicates the top of the stack
-------------------------------------------------------------------------------
Variable management
-------------------------------------------------------------------------------
 DEC <type> <ref> - declare variable of type
 LOV <ref>        - loads reference variable on to stack
 STV <ref>        - stores TOS to reference variable
 LOC <ref>        - loads constant
-------------------------------------------------------------------------------
Type management

   Types are in the air at this moment. I'll detail what types there are when
the time comes
-------------------------------------------------------------------------------
 TYPEOF <ref>      - returns type structure on TOS (used for comparing types)
 CAST <ref> <type> - Tries to cast <ref> to <type>
-------------------------------------------------------------------------------
Arithmetic
    OPS take the two top elements of the stack, preform an operation and push
the result on the stack.
-------------------------------------------------------------------------------
 ADD  - adds the two top elements of the stack and pushes the result
 SUB  - subtracts the two top elements of the stack and pushes the result
 MULT - multiplies the two top elements of the stack and pushes the result
 DIV  - divides the two top elements of the stack and pushes the result
-------------------------------------------------------------------------------
Conditional Expressions

    Things for booleans, < > = ! and so on and so forth.
Behaves like Arithmetic instructions
-------------------------------------------------------------------------------
 GTHAN - Greather than
 LTHAN - Less than
 EQ    - Equal to
 NOT   - Not this.
-------------------------------------------------------------------------------
Loops
-------------------------------------------------------------------------------
 STARTL - Start of loop
 CLOOP  - Conditional loop. If TOS is true, continue looping, else break
 BREAK  - Breaks out of loop
 DONE   - End of loop
-------------------------------------------------------------------------------
Code flow

    These instructions dictate code flow.
-------------------------------------------------------------------------------
 GOTO <addr> - Goes to address
 JUMPF <n>   - Goes forward <n> lines
 CALL <ref>  - Calls function, pushes return value on to STACK. Expects array
               on TOS to be used for arguements
-------------------------------------------------------------------------------
Manipulating High-order Object Variables

    For arrays, key-value arrays, etc
-------------------------------------------------------------------------------
 PUSH <ref>        - Push TOS on to <ref>, expects <ref> to be an object
                     that supports the scheme.
 AT <ref>          - Push element in structure at TOS (assumes it's an index of
                     sorts) for <ref> object. Assumes <ref> supports the scheme.
 DEL <ref> <index> - Delete element in structure at TOS (assumes it's an index
                     of sorts) for <ref> object.

LEXICAL ANALYSIS

    Going from code to bytecode is what this section is all about. First off an
abstract notation for the code will be broken down into a binary tree as so:

                                    <node>
                                      /\
                                     /  \
                                    /    \
                                  <arg> <next>

    <node> can be an argument of its parent node, or the next instruction.
Instruction nodes are nodes that will produce an instruction, or multiple based
on the bytecode interpretation of its instruction. For example, this line of
code:

                                   int x = 3

    would translate into:
                                      def
                                       /\
                                      /  \
                                     /    \
                                    /      \
                                   /        \
                                 int        set
                                 /\          /\
                                /  \        /  \
                              null 'x'    'x'  null
                                          /\
                                         /  \
                                       null  3

    Functions are expressed as individual binary trees. The root of any file is
treated as an individual binary tree, as this is also a function.

    The various instruction nodes are as follows:

 * def <type> <name>
   - Define a named space in memory with the type specified
   - See the 'TYPES' section under 'OVERVIEW'
 * set <name> <value>
   - Set a named space in memory with value specified

                    Going from Binary Trees to Bytecode

    The various instruction nodes within the tree will call specific functions
that will take arguemets specified and lookahead and lookbehind to formulate the
correct bytecode equivilent.
