                             Detailed Specification for
                                  Various Componets

                           Paul Longtine (paul@nanner.co)

OVERVIEW
    This language will look and feel like any other normal, ordinary language.
The goal is not to innovate, but to see if _I_ can. This is a personal refuge
before my inevitable contributions to large group projects where individuals
are deemed inferior.

 SYNTAX
    #TO BE DETERMINED#

 TYPES
    Providing basic types, such as:
 * integer
 * float
 * character
 * boolean
    Will be elaborated on as thoughts progress.

RUNTIME

    Code in the runtime is organized on a per-function basis.

'Function' in this case means a callable block of code which may or may not retu
rn a value.

Scopes are handled by referencing to either the Global Scope, Local Scope.
Local Scope is denoted by '1' in the scope arguement when handling variables,
and this scope is initialized when evaluating any new block of code. When a diff
erent block of code is called, a new scope is initialized and the old scope is
pushed on to the local scope stack. The local scope stack keeps track of previou
s-level scopes, such as when a function returns the local scope stack is popped,
deconstructing variables on the popped local stack.

Global scope variables (denoted by a '0' in the scope arguement) are persistient
through the runtime as they handle all function definitions, objects, and 
variables declared in the global scope.

 +---------+
 |Function | -> Functions are defined with a reference, called with the same
 +---------+    reference. The top elements on the stack are used as arguements
                when calling a function, which must align with the parameter
                types.

 +---------------+
 |Class          |
 | +---------+   | -> Classes are defined as wrappers around functions. Special
 | |Function |   |    functions such as the Constructor function and the Deconst
 | +---------+   |    ructor exist to initialze/clean up properties.
 +---------------+



    A stack is used to keep a local group of values to manipulate. Values are
pushed on to the stack and are operated upon, and the values in the stack can
be assigned or re-assigned to variables.

 Bytecode Instructions

  Interpreting Bytecode Instructions

   Bytecode arguements - After the opcode byte, set-length bytes are used as
                         arguements for the opcode.

   Dynamic Bytecode args - After the opcode byte, a series of bytes terminated
                           by NULL defines a single dynamic-length arguement.
                           NULL can be escaped using the escape byte (encoded)

   Function identifier - 0xFF initiates the beginning of a function, followed by
                         a single dynamic arguement.

Keywords:
 TOS           - 'Top Of Stack' The top element
 S<[variable]> - Static Arguement. Default 1 byte.
 A<[variable]> - Address Arguement. Address width will vary on file size,
                 decided on compile time.
 D<[variable]> - Dynamic bytecode arguement. Arguements terminated with NULL
                 byte.
-------------------------------------------------------------------------------
Stack manipulation
-------------------------------------------------------------------------------
 POP S<n>  - pops the stack n times.
 ROT       - rotates top of stack
 ROT_THREE - rotates top three elements of stack
 DUP       - duplicates the top of the stack
-------------------------------------------------------------------------------
Variable management
-------------------------------------------------------------------------------
 DEC S<scope> S<type> D<ref> - declare variable of type
 LOV S<scope> D<ref>         - loads reference variable on to stack
 STV S<scope> D<ref>         - stores TOS to reference variable
 LOC S<scope> D<ref> D<data> - loads constant into variable
 CTS D<data>                 - loads constant into stack
-------------------------------------------------------------------------------
Type management

   Types are in the air at this moment. I'll detail what types there are when
the time comes
-------------------------------------------------------------------------------
 TYPEOF D<ref>      - returns type structure on TOS (used for comparing types)
 CAST D<ref> S<type> - Tries to cast <ref> to <type>
-------------------------------------------------------------------------------
Arithmetic
    OPS take the two top elements of the stack, preform an operation and push
the result on the stack.
-------------------------------------------------------------------------------
 ADD  - adds the two top elements of the stack and pushes the result
 SUB  - subtracts the two top elements of the stack and pushes the result
 MULT - multiplies the two top elements of the stack and pushes the result
 DIV  - divides the two top elements of the stack and pushes the result
-------------------------------------------------------------------------------
Conditional Expressions

    Things for booleans, < > = ! and so on and so forth.
Behaves like Arithmetic instructions
-------------------------------------------------------------------------------
 GTHAN - Greather than
 LTHAN - Less than
 EQ    - Equal to
 NOT   - Not this.
-------------------------------------------------------------------------------
Loops
-------------------------------------------------------------------------------
 STARTL - Start of loop
 CLOOP  - Conditional loop. If TOS is true, continue looping, else break
 BREAK  - Breaks out of loop
 DONE   - End of loop
-------------------------------------------------------------------------------
Code flow

    These instructions dictate code flow.
-------------------------------------------------------------------------------
 GOTO A<addr> - Goes to address
 JUMPF S<n>   - Goes forward <n> lines
 CALL D<ref>  - Calls function, pushes return value on to STACK. Expects array
                on TOS to be used for arguements
-------------------------------------------------------------------------------
Manipulating High-order Object Variables

    For arrays, key-value arrays, etc
-------------------------------------------------------------------------------
 PUSH         - Push TOS on to TOS1, expects TOS1 to be an object hat
                supports the scheme.

 DEL          - Delete element in structure at TOS (assumes index of
                sorts) for <ref> object.
-------------------------------------------------------------------------------
Functions/classes
-------------------------------------------------------------------------------
 DEFUN D<ref> S<type> D<args> - Un-funs everything. no, no- it defines a
                                function. D<ref> is its name, S<type> is the
                                return value, D<args> is the args.

 DECLASS D<ref>               - Defines a class
-------------------------------------------------------------------------------

LEXICAL ANALYSIS

    Going from code to bytecode is what this section is all about. First off an
abstract notation for the code will be broken down into a binary tree as so:

                                    <node>
                                      /\
                                     /  \
                                    /    \
                                  <arg> <next>

    <node> can be an argument of its parent node, or the next instruction.
Instruction nodes are nodes that will produce an instruction, or multiple based
on the bytecode interpretation of its instruction. For example, this line of
code:

                                   int x = 3

    would translate into:
                                      def
                                       /\
                                      /  \
                                     /    \
                                    /      \
                                   /        \
                                 int        set
                                 /\          /\
                                /  \        /  \
                              null 'x'    'x'  null
                                          /\
                                         /  \
                                       null  3

    Functions are expressed as individual binary trees. The root of any file is
treated as an individual binary tree, as this is also a function.

    The various instruction nodes are as follows:

 * def <type> <name>
   - Define a named space in memory with the type specified
   - See the 'TYPES' section under 'OVERVIEW'
 * set <name> <value>
   - Set a named space in memory with value specified

                    Going from Binary Trees to Bytecode

    The various instruction nodes within the tree will call specific functions
that will take arguemets specified and lookahead and lookbehind to formulate the
correct bytecode equivilent.
