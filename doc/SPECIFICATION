                             Detailed Specification for
                                  Various Componets

                           Paul Longtine (paul@nanner.co)

OVERVIEW
    This language will look and feel like any other normal, ordinary language.
The goal is not to innovate, but to see if _I_ can. This is a personal refuge
before my inevitable contributions to large group projects where individuals
are deemed inferior.

 SYNTAX
    #TO BE DETERMINED#

 TYPES
    Providing basic types, such as:
 * integer
 * float
 * character
 * boolean

Types are structured in memory with an integer representing types, along with a
null pointer to a space in memory containing the data. Building on top of basic
types, there will be more complex data structures built into the virtual machine
such as static Arrays, dynamic Arrays, and a hashtable implementation. Functions
and Classes have their own type, which acts as a pointer to an address within
the program space. For example, variables would be accessed in the runtime, in
code would be like so:

    var_cont* get_variable(ns_cont* namespace, int x)
    {
    	var_cont* var = namespace->names[x];
    	return var;
    }

To set variable:

    void set_variable(ns_cont* namespace, var_cont* var, int x)
    {
    	var_cont* c_var = namespace->names[x];

    	del_var(c_var);

    	var_cont* c_var = var;
    }

Both of these functions require some safeguards against hard crashes, where the
program will segfault if given incorrect values.

________________________________________________________________________________
RUNTIME
--------------------------------------------------------------------------------

TODO: SPEC VARIABLE SERIALZATION


    Code in the runtime is organized on a per-function basis.

'Function' in this case means a callable block of code which may or may not retu
rn a value.

Scopes are handled by referencing to either the Global Scope, Local Scope.
Local Scope is denoted by '1' in the scope arguement when handling variables,
and this scope is initialized when evaluating any new block of code. When a diff
erent block of code is called, a new scope is initialized and the old scope is
pushed on to the local scope stack. The local scope stack keeps track of previou
s-level scopes, such as when a function returns the local scope stack is popped,
deconstructing variables on the popped local stack.

Global scope variables (denoted by a '0' in the scope arguement) are persistient
through the runtime as they handle all function definitions, objects, and 
variables declared in the global scope.

 +---------+
 |Function | -> Functions are defined with a reference, called with the same
 +---------+    reference. The top elements on the stack are used as arguements
                when calling a function, which must align with the parameter
                types.

 +---------------+
 |Class          |
 | +---------+   | -> Classes are defined as wrappers around functions. Special
 | |Function |   |    functions such as the Constructor function and the Deconst
 | +---------+   |    ructor exist to initialze/clean up properties.
 +---------------+



    A stack is used to keep a local group of values to manipulate. Values are
pushed on to the stack and are operated upon, and the values in the stack can
be assigned or re-assigned to variables.

 Bytecode Instructions

  Interpreting Bytecode Instructions

   Bytecode arguements - After the opcode byte, set-length bytes are used as
                         arguements for the opcode.

   Dynamic Bytecode args - After the opcode byte, a series of bytes terminated
                           by NULL defines a single dynamic-length arguement.
                           NULL can be escaped using the escape byte (encoded)

   Function identifier - 0xFF initiates the beginning of a function, followed by
                         a single dynamic arguement.

Keywords:
 TOS           - 'Top Of Stack' The top element
 S<[variable]> - Static Arguement. (1 byte)
 N<[variable]> - Name, word in length
 A<[variable]> - Address Arguement. Address width will vary on file size,
                 decided on compile time. (for now, a word)
 D<[variable]> - Dynamic bytecode arguement. Arguements terminated with NULL
                 byte. Two null bytes escapes terminator.
-------------------------------------------------------------------------------
1 - Stack manipulation
-------------------------------------------------------------------------------
10 POP S<n>  - pops the stack n times.
11 ROT       - rotates top of stack
12 DUP       - duplicates the top of the stack
13 ROT_THREE - rotates top three elements of stack
-------------------------------------------------------------------------------
2 - Variable management
-------------------------------------------------------------------------------
20 DEC S<scope> S<type> N<ref> - declare variable of type
21 LOV S<scope> N<ref>         - loads reference variable on to stack
22 STV S<scope> N<ref>         - stores TOS to reference variable
23 LOC S<scope> N<ref> D<data> - loads constant into variable
24 CTS D<data>                 - loads constant into stack
-------------------------------------------------------------------------------
3 - Type management

   Types are in the air at this moment. I'll detail what types there are when
the time comes
-------------------------------------------------------------------------------
30 TYPEOF              - returns type structure on TOS
                         (used for comparing types)
31 CAST S<type>        - Tries to cast TOS to <type>
-------------------------------------------------------------------------------
4 - Binary Ops
    OPS take the two top elements of the stack, preform an operation and push
the result on the stack.
-------------------------------------------------------------------------------
40 ADD  - adds
41 SUB  - subtracts
42 MULT - multiplies
43 DIV  - divides
44 POW  - power, TOS^TOS1
45 BRT  - base root, TOS root TOS1
46 SIN  - sine
47 COS  - cosine
48 TAN  - tangent
49 ISIN - inverse sine
4A ICOS - inverse consine
4B ITAN - inverse tangent
4C MOD  - modulus
4D OR   - or's
4E XOR  - xor's
4F NAND - and's
-------------------------------------------------------------------------------
5 - Conditional Expressions

    Things for comparison, < > = ! and so on and so forth.
Behaves like Arithmetic instructions, besides NOT instruction. Pushes boolean
to TOS
-------------------------------------------------------------------------------
50 GTHAN - Greather than
51 LTHAN - Less than
52 EQ    - Equal to
53 NOT   - Inverts TOS if TOS is boolean
-------------------------------------------------------------------------------
6 - Loops
-------------------------------------------------------------------------------
60 STARTL - Start of loop
61 CLOOP  - Conditional loop. If TOS is true, continue looping, else break
6E BREAK  - Breaks out of loop
6F DONE   - End of loop
-------------------------------------------------------------------------------
7 - Code flow

    These instructions dictate code flow.
-------------------------------------------------------------------------------
70 GOTO A<addr> - Goes to address
71 JUMPF A<n>   - Goes forward <n> lines
7F CALL N<ref>  - Calls function, pushes return value on to STACK.
-------------------------------------------------------------------------------
8 - Manipulating High-order Object Variables

    For arrays, key-value arrays, etc
-------------------------------------------------------------------------------
80 PUSH         - Push TOS on to TOS1, expects TOS1 to be an object hat
                supports the scheme.

81 DEL          - Delete element in structure at TOS (assumes index of
                sorts) for <ref> object.

82 GET          - Gets key, TOS must be a keyed datastructure, and TOS1 must be
                a string that is a key in TOS.

83 GETP N<ref>  - Get property of <ref> in object contained in TOS. pushes
                to stack

84 CALLM N<ref> - Call method of <ref> in object contained in TOS. Uses
                arguement stack
-------------------------------------------------------------------------------
F - Functions/classes
-------------------------------------------------------------------------------
FF DEFUN N<ref> S<type> D<args> - Un-funs everything. no, no- it defines a
                                  function. D<ref> is its name, S<type> is the
                                  return value, D<args> is the args.

FE DECLASS N<ref> D<args>       - Defines a class.

F1 NEW N<ref>                   - Instantiates class

F0 RETURN                       - Returns from function
-------------------------------------------------------------------------------
0 - SPECIAL BYTES
-------------------------------------------------------------------------------
00 NULL          - Terminator byte

01 SYNC S<level> - Updates global namespace with global namespace cache of 
                   current thread

0E ARGB          - Builds arguement stack

0F LIBC A<ref>   - Library call

-------------------------------------------------------------------------------
General Architecture Overview
-------------------------------------------------------------------------------
RUNTIME CONTEXT

    The runtime context keeps track of a invidual threads metadata, such as:

 * The operating stack

 * Local namespace scope stack

 * Arguement stack

 * Thread instance

 * Global Namespace cache

 * Program counter


FUNCTION CALL PROCEDURE

    When calling a function, arguements are assumed to be built up using the
`ARGB` instruction. TOS is popped into a special stack, named 'arguement stack'
which is a member of the runtime context.

________________________________________________________________________________
COMPILER/TRANSLATOR/ASSEMBLER SHINDIGS
--------------------------------------------------------------------------------

LEXICAL ANALYSIS

    Going from code to bytecode is what this section is all about. First off an
abstract notation for the code will be broken down into a binary tree as so:

                                    <node>
                                      /\
                                     /  \
                                    /    \
                                  <arg> <next>

    <node> can be an argument of its parent node, or the next instruction.
Instruction nodes are nodes that will produce an instruction, or multiple based
on the bytecode interpretation of its instruction. For example, this line of
code:

                                   int x = 3

    would translate into:
                                      def
                                       /\
                                      /  \
                                     /    \
                                    /      \
                                   /        \
                                 int        set
                                 /\          /\
                                /  \        /  \
                              null 'x'    'x'  null
                                          /\
                                         /  \
                                       null  3

    Functions are expressed as individual binary trees. The root of any file is
treated as an individual binary tree, as this is also a function.

    The various instruction nodes are as follows:

 * def <type> <name>
   - Define a named space in memory with the type specified
   - See the 'TYPES' section under 'OVERVIEW'
 * set <name> <value>
   - Set a named space in memory with value specified

                    Going from Binary Trees to Bytecode

    The various instruction nodes within the tree will call specific functions
that will take arguemets specified and lookahead and lookbehind to formulate the
correct bytecode equivilent.
